<!DOCTYPE html>
<html lang="en">
<head>
<title>Asymmetric Passwords</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<script type="text/javascript" src="nacl-fast.js"></script>
<script type="text/javascript" src="apclient.js"></script>
<script type="text/javascript">
<!--
// The MIT License (MIT)
// 
// Copyright (c) 2016, 2017 Mehdi Sotoodeh, KryptoLogik Inc.
// 
// Permission is hereby granted, free of charge, to any person obtaining 
// a copy of this software and associated documentation files (the 
// "Software"), to deal in the Software without restriction, including 
// without limitation the rights to use, copy, modify, merge, publish, 
// distribute, sublicense, and/or sell copies of the Software, and to 
// permit persons to whom the Software is furnished to do so, subject to 
// the following conditions:
// 
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
// CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// 

var user_info_database = {};    // database of registered users

function createToken(form, msg) {
    with (form) {
        var newUser = new apclient();
        newUser.kdf(f_userid.value, f_userpass.value, f_domain.value, msg);
        //f_privateKey.value = b64encode(newUser.privateKey);
        //f_publicKey.value = b64encode(newUser.publicKey);
        //var token = newUser.genToken(msg);
        //msg.submit(form, f_userid.value, token);
    }
}

function onRegisterNewUser(form) {
    createToken(form, 
        {
            tag: 'nu', 
            payload: function(client) { return "ed255." + b64encode(client.publicKey); },
            submit: function(uid, tkn) { serverDispatch_ProcessNewUserToken(form, uid, tkn); },
            view: form,
            showResults: function(client) {
                with (this.view) {
                    f_privateKey.value = b64encode(client.privateKey);
                    f_publicKey.value = b64encode(client.publicKey);
                }
            }
        });
}

function onUserLogin(form) {
    createToken(form, 
        {
            tag: 'li', 
            payload: function(client) { return "600"; },
            submit: function(uid, tkn) { serverDispatch_ProcessUserLoginToken(form, uid, tkn); },
            view: form,
            showResults: function(client) {
                with (this.view) {
                    f_privateKey.value = b64encode(client.privateKey);
                    f_publicKey.value = b64encode(client.publicKey);
                }
            }
        });
}

///////////////////////////////////////////////////////////////////////////////////
// Server side processing
///////////////////////////////////////////////////////////////////////////////////

function serverDispatch_ProcessNewUserToken(form, uid, token) {
  with (form) {
    console.log("signed token: " + token);
    f_tokenString.value = token;
    var new_user = user_info_database[uid];
    if (new_user) {
        f_serverResult.value = "ERROR: User '" + uid + "' already exists.";
    } else {
        var items = token.split('.');
        
        // token format is: tag.timestamp.algo.publicKey.signature
        
        // TODO:
        //  1. Make sure items.length > 4 and tag == 'nu'
        //  2. This token is self-signed, verify its signature
        //  3. Validate timestamp
        //  4. Make sure algo is supported
        
        var kpub = items[3];
        // last item is signature
        var sig = items[items.length-1];
        var msg = utf8StringToU8Array(token.substring(0, token.length - sig.length));
        if (nacl.sign.detached.verify(msg, b64decode(sig), b64decode(kpub))) {
            // Save user info
            new_user = {};
            new_user.algo = items[2];
            new_user.publicKey = kpub;
            user_info_database[uid] = new_user;
            f_serverResult.value = "User '" + uid + "' successfully added.";
        } else {
            f_serverResult.value = "FAILED: signature mismatch!!";
        }
    }
  }
}

function serverDispatch_ProcessUserLoginToken(form, uid, token) {
  with (form) {
    console.log("signed token: " + token);
    f_tokenString.value = token;
    var items = token.split('.');
    
    // token format is: tag.timestamp.duration.signature
    
    // TODO:
    //  1. Make sure items.length > 3 and tag == 'nu'
    //  2. This token is self-signed, verify its signature
    //  3. Validate timestamp
    //  4. Make sure algo is supported
    
    var user_info = user_info_database[uid];
    if (user_info) {
        kpub = user_info.publicKey;
        // last item is signature
        var sig = items[items.length-1];
        var msg = utf8StringToU8Array(token.substring(0, token.length - sig.length));
        // validate signature
        if (nacl.sign.detached.verify(msg, b64decode(sig), b64decode(kpub))) {
            f_serverResult.value = "SUCCESS: User '" + uid + "' logged in.";
        } else {     
            f_serverResult.value = "FAILED: signature mismatch!!";
        }
    } else {
        f_serverResult.value = "ERROR: User '" + uid + "' not exists.";
    }
  }
}

// -->
</script>
</head>
<body style="text-align:right;">
<h1>Asymmetric Passwords</h1>
Copyright (c) 2016, 2017 KryptoLogiK Inc.
<h2>Register New User</h2>
<form name="newUserForm">
Username: <input style="text-align:left;" type="text" name="f_userid" size=64 /><br />
Password: <input style="text-align:left;" type="text" name="f_userpass" size=64 /><br />
Domain: <input style="text-align:left;" type="text" name="f_domain" value="www.example.com" size=64 /><br />
<input type=button onClick="javascript:onRegisterNewUser(newUserForm)" value="Register New User" /><br />
Private key:<input style="text-align:left;" type=text name="f_privateKey" size=64 /><br />
Public key: <input style="text-align:left;" type="text" name="f_publicKey" size=64 /><br />
<code>tag.timestamp.algo.publicKey.nonce.signature</code><br />
<textarea name="f_tokenString" id="newUserToken" readOnly="true" rows="2" cols="64"></textarea><br />
<textarea name="f_serverResult" id="newUserResult" readOnly="true" rows="1" cols="64"></textarea>
</form>
<h2>User Login</h2>
<form name="userLoginForm">
Username: <input style="text-align:left;" type="text" name="f_userid" size=64 /><br />
Password: <input style="text-align:left;" type="text" name="f_userpass" size=64 /><br />
Domain: <input style="text-align:left;" type="text" name="f_domain" value="www.example.com" size=64 /><br />
<input type=button onClick="javascript:onUserLogin(userLoginForm)" value="User Login" /><br />
Private key:<input style="text-align:left;" type=text name="f_privateKey" size=64 /><br />
Public key: <input style="text-align:left;" type="text" name="f_publicKey" size=64 /><br />
<code>tag.timestamp.duration.nonce.signature</code><br />
<textarea name="f_tokenString" id="userLoginToken" rows="2" cols="64"></textarea><br />
<textarea name="f_serverResult" id="userLoginResult" rows="1" cols="64"></textarea>
</form>
</body>
</html>
